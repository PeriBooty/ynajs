var Yna=function(t,n){"use strict";const e=class{constructor(t,n,e){this.name=t,this.options=n,this.data=e}log(t,n){if(this.options.debug){const e=[this.name,...t].join("::");console.log(`${e}: ${JSON.stringify(n)}`)}}},s=(t,n)=>`<${t}:${n.message}>`,r=(n,e="unknown")=>{if(t.isString(n))return n;if(!0===n)return"True";if(!1===n)return"False";if(t.isNil(n))return"None";if(t.isError(n))return s(e,n);return String(n)},i=(t,n)=>{let e=0;t.split("").forEach((t,s)=>{const r={open:"{"===t,close:"}"===t};r.open?e++:r.close&&e--;n(t,s,e,r)});return e},o=class extends e{constructor(t,n){super("PARSER",t,n)}parseString(t,n=!0){const e=[];let r,o,c=0;const a=i(t,(n,s,r,i)=>{const o=t.substr(c,s-c);i.open&&1===r?(e.push(o),c=s):i.close&&0===r&&(e.push(this.parseBlock(o.substr(1,o.length-1))),c=s+1)});if(e.push(t.substr(c)),0!==a)r=s("parser",new Error("mismatched brackets")),o="error";else{const t=n?e.filter(t=>t.length>0):e;1===t.length?(r=t[0],o="single"):(r=t,o="mixed")}return this.log(["string",o],r),r}parseBlock(t){const n=t.trim();let e,s;if(n.startsWith("!")){const n="{"+t.replace("!","")+"}";e=[2,n],s="comment"}else if(n.startsWith(">")){const n="{"+t.replace(">","")+"}";e=n,s="escaped"}else if(n.endsWith(";")){const n=this.parseBlockData(t);e=[1,n.name,n.args],s="command"}else{const n=this.parseString(t);e=[0,n],s="key"}return this.log(["block",s],e),e}parseBlockData(t){const n=[],e={name:"",args:""};let r,o=0,c=!1;return 0!==i(t,(e,s,r)=>{if(0===r&&(";"===e||":"===e&&!c)){const r=this.parseString(t.substr(o,s-o),!0);n.push(r),o=s+1,":"===e&&(c=!0)}})?(e.name=n[0],e.args=s("parser",new Error("mismatched brackets")),r="error"):(e.name=n[0],e.args=n.slice(1),r="mixed"),this.log(["strData",r],e),e}},c={debug:!1,loadJSON:!1},a={debug:!1,depth:0},u={},f=()=>{const n=t.mapFromObject({foo:()=>"foo"});return n},h=t=>n.utc(t).format("YYYY-MM-DD HH:mm:ss:SSSSSS"),m=(e,s)=>{const r=new Map;r.set("time",h(n.utc()));r.set("newrep",!1);r.set("args",e.join(" "));r.set("arglen",e.length);e.forEach((t,n)=>{r.set(`arg${n+1}`,t)});t.forEachEntry(s,(t,n)=>{r.set(n,t)});return r},l=t=>t,g=class extends e{constructor(t,n,e,s){super("RUNNER",e,s),this.commands=t,this.keys=n,this.transformer=l}execItem(n,e){const s=n[0],r=n.slice(1);let i,o;if(e&&(this.transformer=e),0===s){const t=this.execItem(r[0]);i=this.resolveKey(t),o="key"}else if(1===s){const t=this.execItem(r[0]),n=r[1];i=this.resolveCommand(t,n),o="command"}else if(2===s)i="",o="comment";else if(t.isArray(n)){const t=this.execArr(n).join("");i=this.transformer(t),o="array"}else i=n,o="string";return e&&(this.transformer=l),this.log(["item",o],i),i}execArr(t){const n=t.map(t=>this.execItem(t));return this.log(["array"],n),n}resolveCommand(t,n){if(!this.commands.has(t))return s(t,new Error("unknown command"));const e=this.commands.get(t)(this,n);return r(e,t)}resolveKey(n){const e=n.split(".");if(!this.keys.has(e[0]))return s(n,new Error("unknown key"));const i=this.keys.get(e[0]);let o,c=i;if(e.length>1){const r=e.slice(1);if(!t.hasPath(i,r))return s(n,new Error(`does not have '${r}'`));c=t.getPath(i,r)}return o=t.isFunction(c)?c():t.isObjectPlain(c)?c.__default:c,r(o,n)}};return class{constructor(n,e={},s={}){const r=t.objDefaultsDeep(e,c),i=t.objDefaultsDeep(s,u);this.commands=f(),r.loadJSON?this.tree=n:this.tree=new o(r,i).parseString(n)}addCommand(t,n){this.commands.set(t,n)}run(n=[],e={},s={},r={}){const i=t.objDefaultsDeep(s,a),o=t.objDefaults(r,u),c=m(n,e);return new g(this.commands,c,i,o).execItem(this.tree)}}}(lightdash,moment);
//# sourceMappingURL=yna.min.js.map
