var Yna=function(n,t,e,r){"use strict";t=t&&t.hasOwnProperty("default")?t.default:t,r=r&&r.hasOwnProperty("default")?r.default:r;const o=(n,t)=>`<${n}:${t.message}>`,s=(t,e="unknown")=>{if(n.isString(t))return t;if(!0===t)return"True";if(!1===t)return"False";if(n.isNil(t))return"None";if(n.isError(t))return o(e,t);return String(t)},i=class{constructor(n,t,e){this.name=n,this.options=t,this.data=e}log(n,t){if(this.options.debug){const e=[this.name,...n].join("::");console.log(`${e}: ${JSON.stringify(t)}`)}}},c=(n,t)=>{let e=0;n.split("").forEach((n,r)=>{const o={open:"{"===n,close:"}"===n};o.open?e++:o.close&&e--;t(n,r,e,o)});return e},u=class extends i{constructor(n,t){super("PARSER",n,t)}parseString(n,t=!0){const e=[];let r,s,i=0;const u=c(n,(t,r,o,s)=>{const c=n.substr(i,r-i);s.open&&1===o?(e.push(c),i=r):s.close&&0===o&&(e.push(this.parseBlock(c.substr(1,c.length-1))),i=r+1)});if(e.push(n.substr(i)),0!==u)r=o("parser",new Error("mismatched brackets")),s="error";else{const n=t?e.filter(n=>n.length>0):e;1===n.length?(r=n[0],s="single"):(r=n,s="mixed")}return this.log(["string",s],r),r}parseBlock(n){const t=n.trim();let e,r;if(t.startsWith("!")){const t="{"+n.replace("!","")+"}";e=[2,t],r="comment"}else if(t.startsWith(">")){const t="{"+n.replace(">","")+"}";e=t,r="escaped"}else if(t.endsWith(";")){const t=this.parseBlockData(n);e=[1,t.name,t.args],r="command"}else{const t=this.parseString(n);e=[0,t],r="key"}return this.log(["block",r],e),e}parseBlockData(n){const t=[],e={name:"",args:""};let r,s=0,i=!1;return 0!==c(n,(e,r,o)=>{if(0===o&&(";"===e||":"===e&&!i)){const o=this.parseString(n.substr(s,r-s),!0);t.push(o),s=r+1,":"===e&&(i=!0)}})?(e.name=t[0],e.args=o("parser",new Error("mismatched brackets")),r="error"):(e.name=t[0],e.args=t.slice(1),r="mixed"),this.log(["strData",r],e),e}},f=class extends i{constructor(n,t,e,r){super("RUNNER",e,r),this.depth=0,this.defaults={commands:n,keys:t,transformer:n=>n},this.transformer=this.defaults.transformer,this.commands=n,this.keys=t}execItem(t,e){const r=t[0],o=t.slice(1);let s,i;if(e&&(e.transformer&&(this.transformer=e.transformer),e.commands&&(this.commands=e.commands),e.keys&&(this.keys=e.keys)),0===r){const n=this.execItem(o[0]);s=this.resolveKey(n),i="key"}else if(1===r){const n=this.execItem(o[0]),t=o[1];s=this.resolveCommand(n,t),i="command"}else if(2===r)s="",i="comment";else if(n.isArray(t)){const n=this.execArr(t).join("");s=this.transformer(n),i="array"}else s=t,i="string";return e&&(this.transformer===e.transformer&&(this.transformer=this.defaults.transformer),this.commands===e.commands&&(this.commands=this.defaults.commands),this.keys===e.keys&&(this.keys=this.defaults.keys)),this.log(["item",i],s),s}execArr(n){const t=n.map(n=>this.execItem(n));return this.log(["array"],t),t}resolveCommand(n,t){if(!this.commands.has(n))return o(n,new Error("unknown command"));const e=this.commands.get(n)(this,t);return"object"==typeof e?e.__default?e:("[object Object]"==e.toString()?e.__default=`<${n}:object>`:e.__default=e.toString(),e):s(e,n)}resolveKey(t){const e=t.split(".");if(!this.keys.has(e[0]))return o(t,new Error("unknown key"));const r=this.keys.get(e[0]);let i,c=r;if(e.length>1){const s=e.slice(1);if(!n.hasPath(r,s))return o(t,new Error(`does not have '${s}'`));c=n.getPath(r,s)}return i=n.isFunction(c)?c():n.isObjectPlain(c)?c.__default:c,s(i,t)}},a={debug:!1},g={},h=Math.pow(2,32)-1,m=1-Math.pow(2,32),l=/^[a-z_][0-9a-z_]*$/i,d=n=>l.test(n.trim()),p=n=>n.split(","),w=n=>n.includes(","),E=n=>"string"==typeof n?n.replace("\n","\\\\n"):n,y=(n,t)=>{if(0===t.length)return new Error("no args");if(t.length<2)return new Error("invalid args");const e=n.execItem(t[0]);if(!d(e))return new Error("invalid key");const r=e=>{let r;n.depth++;if(n.depth>15)return new Error("max recursion depth exceeded");r=E(n.transformer(n.execItem(t[1],{keys:e})));n.depth--;return r};const o=(n,t)=>{const e=n.execItem(t);const o=p(e);const s=new Map(n.keys);s.set("targs",e);s.set("talen",o.length);o.forEach((n,t)=>{s.set(`ta${t+1}`,n)});return r(s)};n.keys.set(e,r);n.commands.set(e,o);return""},b=(n,t)=>{if(0===t.length)return new Error("no args");if(2!==t.length)return new Error("invalid args");const e=n.execArr(t);const r=e[0];if(!d(r))return new Error("invalid key");const o=E(n.transformer(e[1]));n.keys.set(r,o);return""},x=/^-?\d+$/,k=n=>parseInt(String(n).trim(),10),I=n=>x.test(String(n).trim()),v=/^[+-]?[0-9]+$/,R=n=>v.test(String(n).trim()),L=(n,e="%H:%M")=>t(n,e.trim()),j=(n,t)=>{let r=e.utc();const o=t[0]?n.execItem(t[0]):"0";if(!R(o))return new Error("invalid offset");const s=k(o);const i=t[1]?n.execItem(t[1]):"%H:%M";r=r.utcOffset(s);return L(r,i)},S=/^-?\d+(?:\.\d+)?$/,M=n=>parseFloat(String(n).trim()),O=n=>S.test(String(n).trim()),A=/^<[a-z][a-z0-9_]*:[a-z0-9 ]+>$/,D=n=>A.test(n.trim()),_=n=>1===n.length,F=n=>!n.includes(" "),z=n.mapFromObject({word:F,letter:_,number:I,decimal:O,error:D}),N=n.mapFromObject({eq:{type:"any",fn:(n,t)=>n===t},ne:{type:"any",fn:(n,t)=>n!==t},gt:{type:"number",fn:(n,t)=>n>t},ge:{type:"number",fn:(n,t)=>n>=t},lt:{type:"number",fn:(n,t)=>n<t},le:{type:"number",fn:(n,t)=>n<=t},in:{type:"any",fn:(n,t)=>{const e=w(t)?p(t):t;return e.includes(n)}},is:{type:"any",fn:(n,t)=>{const e=z.get(t);return e(n)}}}),$=n.mapFromObject({"=":"eq","==":"eq","!=":"ne","<>":"ne",">=":"ge",">":"gt","<=":"le","<":"lt"}),P=(n,t)=>{if(t.length<4||t.length>5)return new Error("invalid args");let e=n.execItem(t[0]);let r=n.execItem(t[2]);const o=n.execItem(t[1]);const s=()=>n.execItem(t[3]);const i=t[4]?()=>n.execItem(t[4]):()=>"";let c;if(N.has(o))c=N.get(o);else{if(!$.has(o))return new Error("invalid op");c=N.get($.get(o))}if("number"===c.type){if(!I(e)||!I(r))return new Error("args must be numbers");e=k(e),r=k(r)}else if("is"===o&&!z.has(r))return new Error("invalid type name");return c.fn(e,r)?s():i()},W=n.mapFromObject({add:{argsLengthRange:[2,1/0],fn:(...n)=>n.reduce((n,t)=>n+t)},sub:{argsLengthRange:[2,2],fn:(...n)=>n.reduce((n,t)=>n-t)},mul:{argsLengthRange:[2,1/0],fn:(...n)=>n.reduce((n,t)=>n*t)},pow:{argsLengthRange:[2,2],fn:Math.pow},div:{argsLengthRange:[2,2],fn:(n,t)=>0!==t?n/t:new Error("divide by zero")},idiv:{argsLengthRange:[2,2],fn:(n,t)=>0!==t?Math.floor(n/t):new Error("divide by zero")},mod:{argsLengthRange:[2,2],fn:(n,t)=>n%t},and:{argsLengthRange:[2,1/0],fn:(...n)=>[-1,...n].reduce((n,t)=>n&t)},or:{argsLengthRange:[2,1/0],fn:(...n)=>[0,...n].reduce((n,t)=>n|t)},xor:{argsLengthRange:[2,2],fn:(n,t)=>n^t},not:{argsLengthRange:[1,1],fn:n=>~n},round:{argsLengthRange:[1,1],fn:Math.round},floor:{argsLengthRange:[1,1],fn:Math.floor},ceil:{argsLengthRange:[1,1],fn:Math.ceil},max:{argsLengthRange:[2,1/0],fn:Math.max},min:{argsLengthRange:[2,1/0],fn:Math.min}}),C=n.mapFromObject({"+":"add","-":"sub","*":"mul","**":"pow","/":"div","/f":"div","//":"idiv","%":"mod","&":"and","|":"or","^":"xor","~":"not"}),Y=(n,t)=>{if(0===t.length)return new Error("no args");const e=n.execItem(t[0]);const r=t.slice(1);let o;let s;let i;if(W.has(e))o=W.get(e);else{if(!C.has(e))return new Error("unknown operation");o=W.get(C.get(e))}if(!(r.length>=o.argsLengthRange[0]&&r.length<=o.argsLengthRange[1]))return new Error("invalid args");s=n.execArr(r);if(s.some(n=>!O(n)))return new Error("non-number args");s=s.map(M);i=o.fn(...s);if(i>h)return new Error("inf");if(i<m)return new Error("-inf");return i},H=(t,e)=>{if(0===e.length)return new Error("no options");const r=t.execArr(e);return n.randItem(r)},U=(t,e)=>{if(0===e.length)return new Error("no args");const r=t.execArr(e);if(!r.every(O))return new Error("invalid args");let o=0;let s=100;let i=1;1===r.length?s=M(r[0]):(o=M(r[0]),s=M(r[1]));3===r.length&&(i=M(r[2]));if(o===s||0===i)return new Error("invalid range");const c=n.randNumber(o,s,!Number.isInteger(i));return Math.floor(c/i)*i},q=(t,e)=>{if(0===e.length)return new Error("no options");if(e.length%2!=0)return new Error("mismatched weighting");const r=t.execArr(e);const o=[];const s=[];let i=!0;r.forEach((n,t)=>{t%2==0?s.push(n):I(n)?o.push(k(n)):i=!1});if(!i)return new Error("invalid weight");const c=[];o.forEach((n,t)=>{const e=s[t];const r=new Array(n).fill(e);c.push(...r)});return n.randItem(c)},B=(n,t)=>{if(0===t.length)return new Error("no content");const e=n.execItem(t[0]);return e.length},J=(n,t)=>{if(0===t.length)return new Error("no content");const e=n.execItem(t[0]);return e.toLowerCase()},K=(n,t)=>{if(0===t.length)return new Error("no content");const e=n.execItem(t[0]);return encodeURI(e)},T=n=>n.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&"),G=n=>n.substr(1,n.length-2),Q=n=>n.length>2&&n.startsWith("/")&&n.endsWith("/"),V=n=>{let t=!0;try{new RegExp(G(n))}catch(n){t=!1}return t},X=n=>new RegExp(G(n)),Z=(n,t)=>{if(0===t.length)return new Error("no content");if(3!==t.length)return new Error("invalid args");const e=n.execArr(t);const r=n.keys.get("newrep");const o=e[0];const s=r?e[2]:e[1];const i=r?e[1]:e[2];const c=Q(o)&&V(o)?X(o):new RegExp(T(o),"g");return s.replace(c,i)},nn=(n,t)=>{if(0===t.length)return new Error("no args");if(2!==t.length)return new Error("bad content");const e=n.execArr(t);const o=e[1];const s=w(e[0])?p(e[0]):[e[0]];if(s.length>3)return new Error("too many nums");if(!s.every(n=>I(n)||""===n))return new Error("non int index");const i=s.map(n=>""!==n&&k(n));if(0===i[2])return new Error("zero step");if(!1===i[2])return r(o,i[0],i[1]);return r(o,i[0],i[1],i[2])},tn=/\s/,en=n=>{let t=!0;return n.split("").map(n=>{const e=tn.test(n);let r=n.toLowerCase();t&&!e&&(t=!1,r=n.toUpperCase());t=e;return r}).join("")},rn=(n,t)=>{if(0===t.length)return new Error("no content");const e=n.execItem(t[0]);return en(e)},on=(n,t)=>{if(0===t.length)return new Error("no content");const e=n.execItem(t[0]);return e.toUpperCase()},sn=n=>{let t=n.trimLeft();n.endsWith("\\")&&(t=t.substr(0,t.length-"\\".length)+"\\n");return t},cn=n=>{const t=n.split("\n").map(n=>sn(n)).join("");return t.replace(/\\n/g,"\n")},un=(n,t)=>{if(0===t.length)return new Error("no content");const e=n.execItem(t[0],{transformer:cn});return cn(e)},fn=(n,t)=>{n.execItem(t[0]);return""},an=()=>n.mapFromObject({set:b,func:y,time:j,when:P,math:Y,len:B,upper:on,lower:J,title:rn,rep:Z,parse:K,slice:nn,num:U,choose:H,wchoose:q,oneline:un,void:fn}),gn=n=>n.format("YYYY-MM-DD HH:mm:ss:SSSSSS"),hn=(t,r)=>{const o=new Map;o.set("time",gn(e.utc()));o.set("newrep",!1);o.set("args",t.join(" "));o.set("arglen",t.length);t.forEach((n,t)=>{o.set(`arg${t+1}`,n)});n.forEachEntry(r,(n,t)=>{o.set(n,t)});return o};return class{constructor(t,e={},r={}){const o=n.objDefaultsDeep(e,a),s=n.objDefaultsDeep(r,g);this.commands=an(),n.isObject(t)?this.tree=t:this.tree=new u(o,s).parseString(t)}addCommand(n,t){this.commands.set(n,t)}run(t=[],e={},r={},o={}){const s=n.objDefaultsDeep(r,a),i=n.objDefaults(o,g),c=hn(t,e);return new f(this.commands,c,s,i).execItem(this.tree)}}}(lightdash,pydateformat,moment,pyslice);
//# sourceMappingURL=yna.min.js.map
