var Yna=function(n,t){"use strict";const e=class{constructor(n,t,e){this.name=n,this.options=t,this.data=e}log(n,t){if(this.options.debug){const e=[this.name,...n].join("::");console.log(`${e}: ${JSON.stringify(t)}`)}}},r=(n,t)=>`<${n}:${t.message}>`,o=(t,e="unknown")=>{if(n.isString(t))return t;if(!0===t)return"True";if(!1===t)return"False";if(n.isNil(t))return"None";if(n.isError(t))return r(e,t);return String(t)},s=(n,t)=>{let e=0;n.split("").forEach((n,r)=>{const o={open:"{"===n,close:"}"===n};o.open?e++:o.close&&e--;t(n,r,e,o)});return e},i=class extends e{constructor(n,t){super("PARSER",n,t)}parseString(n,t=!0){const e=[];let o,i,a=0;const c=s(n,(t,r,o,s)=>{const i=n.substr(a,r-a);s.open&&1===o?(e.push(i),a=r):s.close&&0===o&&(e.push(this.parseBlock(i.substr(1,i.length-1))),a=r+1)});if(e.push(n.substr(a)),0!==c)o=r("parser",new Error("mismatched brackets")),i="error";else{const n=t?e.filter(n=>n.length>0):e;1===n.length?(o=n[0],i="single"):(o=n,i="mixed")}return this.log(["string",i],o),o}parseBlock(n){const t=n.trim();let e,r;if(t.startsWith("!")){const t="{"+n.replace("!","")+"}";e=[2,t],r="comment"}else if(t.startsWith(">")){const t="{"+n.replace(">","")+"}";e=t,r="escaped"}else if(t.endsWith(";")){const t=this.parseBlockData(n);e=[1,t.name,t.args],r="command"}else{const t=this.parseString(n);e=[0,t],r="key"}return this.log(["block",r],e),e}parseBlockData(n){const t=[],e={name:"",args:""};let o,i=0,a=!1;return 0!==s(n,(e,r,o)=>{if(0===o&&(";"===e||":"===e&&!a)){const o=this.parseString(n.substr(i,r-i),!0);t.push(o),i=r+1,":"===e&&(a=!0)}})?(e.name=t[0],e.args=r("parser",new Error("mismatched brackets")),o="error"):(e.name=t[0],e.args=t.slice(1),o="mixed"),this.log(["strData",o],e),e}},a={debug:!1,loadJSON:!1},c={debug:!1,depth:0},u={},f=/^-?\d+\.?\d*$/,h=parseFloat,g=n=>f.test(String(n)),m=(t,e)=>{if(0===e.length)return new Error("no args");const r=t.execArr(e);if(!r.every(g))return new Error("invalid args");let o=0;let s=100;let i=1;1===r.length?s=h(r[0]):(o=h(r[0]),s=h(r[1]));3===r.length&&(i=h(r[2]));if(o===s||0===i)return new Error("invalid range");const a=n.randNumber(o,s,!Number.isInteger(i));return Math.floor(a/i)*i},l=(t,e)=>{if(0===e.length)return new Error("no options");const r=t.execArr(e);return n.randItem(r)},d=(t,e)=>{if(0===e.length)return new Error("no options");if(e.length%2!=0)return new Error("mismatched weighting");const r=t.execArr(e);const o=[];const s=[];let i=!0;r.forEach((n,t)=>{t%2==0?s.push(n):g(n)?o.push(h(n)):i=!1});if(!i)return new Error("invalid weight");const a=[];o.forEach((n,t)=>{const e=s[t];const r=new Array(n).fill(e);a.push(...r)});return n.randItem(a)},p=Math.pow(2,32)-1,w=1-Math.pow(2,32),E=n.mapFromObject({add:{argsLengthRange:[2,1/0],fn:(...n)=>n.reduce((n,t)=>n+t)},sub:{argsLengthRange:[2,2],fn:(...n)=>n.reduce((n,t)=>n-t)},mul:{argsLengthRange:[2,1/0],fn:(...n)=>n.reduce((n,t)=>n*t)},pow:{argsLengthRange:[2,2],fn:Math.pow},div:{argsLengthRange:[2,2],fn:(n,t)=>0!==t?n/t:new Error("divide by zero")},idiv:{argsLengthRange:[2,2],fn:(n,t)=>0!==t?Math.floor(n/t):new Error("divide by zero")},mod:{argsLengthRange:[2,2],fn:(n,t)=>n%t},and:{argsLengthRange:[2,1/0],fn:(...n)=>[-1,...n].reduce((n,t)=>n&t)},or:{argsLengthRange:[2,1/0],fn:(...n)=>[0,...n].reduce((n,t)=>n|t)},xor:{argsLengthRange:[2,2],fn:(n,t)=>n^t},not:{argsLengthRange:[1,1],fn:n=>~n},round:{argsLengthRange:[1,1],fn:Math.round},floor:{argsLengthRange:[1,1],fn:Math.floor},ceil:{argsLengthRange:[1,1],fn:Math.ceil},max:{argsLengthRange:[2,1/0],fn:Math.max},min:{argsLengthRange:[2,1/0],fn:Math.min}}),b=n.mapFromObject({"+":"add","-":"sub","*":"mul","**":"pow","/":"div","/f":"div","//":"idiv","%":"mod","&":"and","|":"or","^":"xor","~":"not"}),R=(n,t)=>{if(0===t.length)return new Error("no args");const e=n.execItem(t[0]);const r=t.slice(1);let o;let s;let i;if(E.has(e))o=E.get(e);else{if(!b.has(e))return new Error("unknown operation");o=E.get(b.get(e))}if(!(r.length>=o.argsLengthRange[0]&&r.length<=o.argsLengthRange[1]))return new Error("invalid args");s=n.execArr(r);if(s.some(n=>!g(n)))return new Error("non-number args");s=s.map(h);i=o.fn(...s);if(i>p)return new Error("inf");if(i<w)return new Error("-inf");return i},L=()=>{const t=n.mapFromObject({math:R,num:m,choose:l,wchoose:d});return t},x=n=>t.utc(n).format("YYYY-MM-DD HH:mm:ss:SSSSSS"),y=(e,r)=>{const o=new Map;o.set("time",x(t.utc()));o.set("newrep",!1);o.set("args",e.join(" "));o.set("arglen",e.length);e.forEach((n,t)=>{o.set(`arg${t+1}`,n)});n.forEachEntry(r,(n,t)=>{o.set(t,n)});return o},S=n=>n,k=class extends e{constructor(n,t,e,r){super("RUNNER",e,r),this.commands=n,this.keys=t,this.transformer=S}execItem(t,e){const r=t[0],o=t.slice(1);let s,i;if(e&&(this.transformer=e),0===r){const n=this.execItem(o[0]);s=this.resolveKey(n),i="key"}else if(1===r){const n=this.execItem(o[0]),t=o[1];s=this.resolveCommand(n,t),i="command"}else if(2===r)s="",i="comment";else if(n.isArray(t)){const n=this.execArr(t).join("");s=this.transformer(n),i="array"}else s=t,i="string";return e&&(this.transformer=S),this.log(["item",i],s),s}execArr(n){const t=n.map(n=>this.execItem(n));return this.log(["array"],t),t}resolveCommand(n,t){if(!this.commands.has(n))return r(n,new Error("unknown command"));const e=this.commands.get(n)(this,t);return o(e,n)}resolveKey(t){const e=t.split(".");if(!this.keys.has(e[0]))return r(t,new Error("unknown key"));const s=this.keys.get(e[0]);let i,a=s;if(e.length>1){const o=e.slice(1);if(!n.hasPath(s,o))return r(t,new Error(`does not have '${o}'`));a=n.getPath(s,o)}return i=n.isFunction(a)?a():n.isObjectPlain(a)?a.__default:a,o(i,t)}};return class{constructor(t,e={},r={}){const o=n.objDefaultsDeep(e,a),s=n.objDefaultsDeep(r,u);this.commands=L(),o.loadJSON?this.tree=t:this.tree=new i(o,s).parseString(t)}addCommand(n,t){this.commands.set(n,t)}run(t=[],e={},r={},o={}){const s=n.objDefaultsDeep(r,c),i=n.objDefaults(o,u),a=y(t,e);return new k(this.commands,a,s,i).execItem(this.tree)}}}(lightdash,moment);
//# sourceMappingURL=yna.min.js.map
