var Yna=function(t,n){"use strict";const s=class{constructor(t,n,s){this.name=t,this.options=n,this.data=s}log(t,n){if(this.options.debug){const s=[this.name,...t].join("::");console.log(`${s}: ${JSON.stringify(n)}`)}}},e=(t,n)=>`<${t}:${n.message}>`,o=(n,s="unknown")=>t.isString(n)?n:!0===n?"True":!1===n?"False":t.isNil(n)?"None":t.isError(n)?e(s,n):String(n),r=(t,n)=>{let s=0;t.split("").forEach((t,e)=>{const o={open:"{"===t,close:"}"===t};o.open?s++:o.close&&s--;n(t,e,s,o)});return s},i=class extends s{constructor(t,n){super("PARSER",t,n)}parseString(t,n=!0){const s=[];let o,i,c=0;const a=r(t,(n,e,o,r)=>{const i=t.substr(c,e-c);r.open&&1===o?(s.push(i),c=e):r.close&&0===o&&(s.push(this.parseBlock(i.substr(1,i.length-1))),c=e+1)});if(s.push(t.substr(c)),0!==a)o=e("parser",new Error("mismatched brackets")),i="error";else{const t=n?s.filter(t=>t.length>0):s;1===t.length?(o=t[0],i="single"):(o=t,i="mixed")}return this.log(["string",i],o),o}parseBlock(t){const n=t.trim();let s,e;if(n.startsWith("!")){const n="{"+t.replace("!","")+"}";s=[2,n],e="comment"}else if(n.startsWith(">")){const n="{"+t.replace(">","")+"}";s=n,e="escaped"}else if(n.endsWith(";")){const n=this.parseBlockData(t);s=[1,n.name,n.args],e="command"}else{const n=this.parseString(t);s=[0,n],e="key"}return this.log(["block",e],s),s}parseBlockData(t){const n=[],s={name:"",args:""};let o,i=0,c=!1;return 0!==r(t,(s,e,o)=>{if(0===o&&(";"===s||":"===s&&!c)){const o=this.parseString(t.substr(i,e-i),!0);n.push(o),i=e+1,":"===s&&(c=!0)}})?(s.name=n[0],s.args=e("parser",new Error("mismatched brackets")),o="error"):(s.name=n[0],s.args=n.slice(1),o="mixed"),this.log(["strData",o],s),s}},c={debug:!1,loadJSON:!1},a={debug:!1,depth:0},u={},h=()=>{const n=t.mapFromObject({foo:()=>"foo"});return n},f=t=>n.utc(t).format("YYYY-MM-DD HH:mm:ss:SSSSSS"),m=(s,e)=>{const o=new Map;o.set("time",f(n.utc()));o.set("newrep",!1);o.set("args",s.join(" "));o.set("arglen",s.length);s.forEach((t,n)=>{o.set(`arg${n+1}`,t)});t.forEachEntry(e,(t,n)=>{o.set(n,t)});return o},l=t=>t,g=class extends s{constructor(t,n,s,e){super("RUNNER",s,e),this.commands=t,this.keys=n,this.transformer=l}execItem(t,n){const s=t[0],e=t.slice(1);let o,r;if(n&&(this.transformer=n),s===IDS.key){const t=this.execItem(e[0]);o=this.resolveKey(t),r="key"}else if(s===IDS.command){const t=this.execItem(e[0]),n=e[1];o=this.resolveCommand(t,n),r="command"}else if(s===IDS.comment)o="",r="comment";else if(isArray(t)){const n=this.execArr(t).join("");o=this.transformer(n),r="array"}else o=t,r="string";return n&&(this.transformer=l),this.log(["item",r],o),o}execArr(t){const n=t.map(t=>this.execItem(t));return this.log(["array"],n),n}resolveCommand(t,n){if(!this.commands.has(t))return e(t,new Error("unknown command"));const s=this.commands.get(t).call(this,n);return o(s,t)}resolveKey(t){const n=t.split(LANGUAGE_YNA.control.data.prop);if(!this.keys.has(n[0]))return e(t,new Error("unknown key"));const s=this.keys.get(n[0]);let r,i=s;if(n.length>1){const o=n.slice(1);if(!hasPath(s,o))return e(t,new Error(`does not have '${o}'`));i=getPath(s,o)}return r=isFunction(i)?i():isObjectPlain(i)?i.__default:i,o(r,t)}};return class{constructor(n,s={},e={}){const o=t.objDefaultsDeep(s,c),r=t.objDefaultsDeep(e,u);this.commands=h(),o.loadJSON?this.tree=n:this.tree=new i(o,r).parseString(n)}addCommand(t,n){this.commands.set(t,n)}run(n=[],s={},e={},o={}){const r=t.objDefaultsDeep(e,a),i=t.objDefaults(o,u),c=m(n,s);return console.log(c),new g(this.commands,c,r,i).execItem(this.tree)}}}(lightdash,moment);
//# sourceMappingURL=yna.min.js.map
